---
title: "Exploration"
author: "Evan Canfield"
date: "3/15/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Purpose
Processing of **osmdata** in order to prepare for visualizations.

# Import
## Packages
```{r import_packages}
if (!require(pacman)) {install.packages("pacman")}
pacman::p_load(
  data.table,
  dodgr,
  rgdal,
  sf,
  sp,
  tidyverse
)
```

## Data
```{r import_data}
# OSM Data
clt <- readRDS("./../data/osm_streets_charlotte_nc_2021-03-16.RDS")
clt_streets <- clt$osm_lines

# Zipcode Shapefile
zip_shapefile <- readOGR("./../data/tl_2019_us_zcta510/tl_2019_us_zcta510.shp")

# List of ZIP codes
clt_zip_codes <- read.csv(
  "./../data/zip_code_charlotte.csv", 
  colClasses = ("zip_code" = "character"),
  stringsAsFactors = FALSE
  ) %>% pull()
```

# Processing
## Dodgr Conversion
The form of the final mapping dataframe will be based on the **dodgr** package. This means instead of representing streets as **sf** objects, as they are represented in the **osmdata**, the streets will be a **dodgr_streetnet**, which is represented as a regular data.frame object.

The first step to this conversion is to create a *weighted streetnet* with the **weight_streetnet** function. This function weights an **sf** formatted OSM street network based on a transportation method. For this project, the weighting method does not matter. We only care about the *weighted streetnet's*  structure, so we will stick with the functions default settings.
```{r weight_streetnet}
clt_streets_wgt <- weight_streetnet(clt_streets)

clt_streets_wgt.df <- clt_streets_wgt %>% data.frame()

# Convert edge_id and geom_num to char
clt_streets_wgt.df <- clt_streets_wgt.df %>% 
  mutate(
    geom_num = as.character(geom_num),
    edge_id = as.character(edge_id)
  )

# Hmisc::describe(clt_streets_wgt.df$edge_id)
```

## Select Highway Tags
The dataset is very large, and will result in very long processing times. In order to limit this, we will remove street segment associated with highway tags we do not want to keep in the dataset.
```{r}
highway_tags <- c("service", "cycleway", "steps", "bridleway", "track")

clt_streets_wgt.df <- clt_streets_wgt.df %>% 
  filter(!highway %in% highway_tags)
```

## ZIP Code Look-Up
For the visualization process we want to be able to know what ZIP code each segment is located in. To do this we'll need to perform a reverse look-up. We'll do this using the United States ZIP Code Tabulation Area (ZCTA) shapefile, from the US Census Bureau. ZTCAs are approximate area representations of USPS ZIP codes.

[https://catalog.data.gov/dataset/tiger-line-shapefile-2019-2010-nation-u-s-2010-census-5-digit-zip-code-tabulation-area-zcta5-na](https://catalog.data.gov/dataset/tiger-line-shapefile-2019-2010-nation-u-s-2010-census-5-digit-zip-code-tabulation-area-zcta5-na) (Accessed on 3/16/2021)

With the shapefile providing the spatial boundaries of each ZIP code, we can determine the missing ZIP codes by the latitude/longitude data associated with each affected segment.

The method used for reverse geocode look-ups is outlined in the following Stack Overflow post:

[https://stackoverflow.com/questions/42337619/how-to-batch-reverse-geocode-in-r](https://stackoverflow.com/questions/42337619/how-to-batch-reverse-geocode-in-r)

```{r zip_code}
# Extract latitude/longitude for each segment
lat_lon_to <- clt_streets_wgt.df %>% select(to_lon:to_lat)
lat_lon_from <- clt_streets_wgt.df %>% select(from_lon:from_lat)

# Transform to SpatialPointsDataFrame
CRSobj <- "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"

spdf_to <- SpatialPointsDataFrame(
  coords = lat_lon_to, 
  data = clt_streets_wgt.df, 
  proj4string = CRS(CRSobj)
  )

spdf_from <- SpatialPointsDataFrame(
  coords = lat_lon_from, 
  data = clt_streets_wgt.df, 
  proj4string = CRS(CRSobj)
  )

# Transform ZIP code shapefile
zip_xfrm <- spTransform(
  x = zip_shapefile, 
  CRSobj = CRSobj
  )

# Subset to only zipcodes where points are found
zip_to_subset <- zip_xfrm[spdf_to, ]
zip_from_subset <- zip_xfrm[spdf_from, ]

# Identify ZIP code if lat/lon exists inside polygon
to_zip <- over(spdf_to, zip_to_subset[,"ZCTA5CE10"])
from_zip <- over(spdf_from, zip_from_subset[,"ZCTA5CE10"])

# Convert to dataframe
to_zip.df <- as.data.frame(to_zip$ZCTA5CE10)
from_zip.df <- as.data.frame(from_zip$ZCTA5CE10)

# Bind columns to street network
clt_streets_wgt.df <- clt_streets_wgt.df %>% 
  cbind(from_zip.df, to_zip.df) %>% 
  rename(
    from_zip = "from_zip$ZCTA5CE10",
    to_zip = "to_zip$ZCTA5CE10"
    )
```


We'll want to see the frequency breakdown by ZIP code for a sanity check.
```{r}
clt_streets_wgt.df %>% 
  group_by(to_zip) %>% 
  summarise(
    freq = round( 100 * n() / nrow(clt_streets_wgt.df), 2)
    ) %>%
  mutate(
    to_zip = as.numeric(to_zip)
  ) %>% 
  arrange(freq)
```

## Drop Select ZIP Codes
The process of extracting **osmdata** grabs data within a bounding box around the queried area. This means streets in neighboring counties outside of the Charlotte/Mecklenburg area are also included. For this project we do not care about these areas. In order to reduce our dataset and remove these outlying areas we will define the ZIP codes we want to keep, and filter our data by these codes.
```{r}
clt_streets_wgt.df <- clt_streets_wgt.df %>% 
  filter(
    from_zip %in% clt_zip_codes |
    to_zip %in% clt_zip_codes
    )

clt_streets_wgt.df %>%
  group_by(to_zip) %>% 
  summarise(
    freq = round( 100 * n() / nrow(clt_streets_wgt.df), 2)
    ) %>%
  mutate(
    to_zip = as.numeric(to_zip)
  ) %>% 
  arrange(freq)
```

## Street Names
With the street segments now created, we can add back the useful descriptive information for each segment, such as street name.

With the descriptive information available, we can now join it to the street network data.frame, using the **osm_id** variable and the joining key.
```{r add_descriptive_information}
# Select descriptive columns
clt_streets_desc <- clt_streets %>%
  data.frame() %>% 
  select(
    osm_id, tiger.county, tiger.name_base, 
    tiger.name_base, tiger.name_type
    ) 

# Join to street network
clt_streets_wgt.df <- clt_streets_wgt.df %>%
  rename(osm_id = way_id) %>% 
  left_join(
    clt_streets_desc, 
    by = "osm_id"
  ) 
```

#### Inspect
```{r}
clt_streets_wgt.df %>% glimpse()

Hmisc::describe(clt_streets_wgt.df$edge_id)
```

## Unique Identifier
There is a worry that in the future, when the street network is updated, it will be difficult to connect old segment IDs to new segment IDs. If this is not possible, it will require a lot of rework to re-record the status of each segment. Therefore, it would be useful to have a unique identifier for each segment.

To ensure the segment is consistent, we can concatenate the to/from latitude/longitude data. We can surmise if this information does not change, the segment is the same.
```{r}
clt_streets_wgt.df <- clt_streets_wgt.df %>% 
  mutate(
    segment_id = paste(abs(to_lon), abs(to_lat), abs(from_lon), 
                       abs(from_lat), sep = "_")
  )
```

## Drop Columns
There are several columns we do not need for this project. 
```{r}
clt_streets_wgt.df <- clt_streets_wgt.df %>% 
  select(
    geom_num:to_lat, highway, 
    osm_id, from_zip:to_zip,
    tiger.county:tiger.name_type)
```

# Export
We will now export two files. The first is the complete street network table.
```{r export_network}
# Define creation date
creation_date <- Sys.Date()

# Street Network - Complete
file_name_street <- paste(
  "dodgr_network_charlotte_nc_", creation_date,
  ".RDS", sep = ""
  )
file_path_street <- file.path(".", "..", "data", file_name_street)
saveRDS(clt_streets_wgt.df, file_path_street)

```

The second file will be a subset of this table. The subset will have the segment unique identifier, some descriptive information, and our classification label column. This column will indicate if a street has been walked or not. We will use this subset file to track our progress. It will be joined to the street network when we want to update the progress in our visualizations.
```{r export_tracking}
# Tracking table - initial
tracking.df <- clt_streets_wgt.df %>% 
  select(edge_id:to_lat, tiger.name_base:tiger.name_type) %>% 
  mutate(status = 0)

file_name_tracking_rds <- paste(
  "tracking_charlotte_nc_blank_", 
  creation_date, ".RDS", sep = ""
)
file_name_tracking_csv <- paste(
  "tracking_charlotte_nc_blank_", 
  creation_date, ".CSV", sep = ""
)
file_path_tracking_rds <- file.path(".", "..", "data", file_name_tracking_rds)
file_path_tracking_csv <- file.path(".", "..", "data", file_name_tracking_csv)

saveRDS(tracking.df, file_path_tracking_rds)
fwrite(tracking.df, file_path_tracking_csv)
```

